<?php
// $Id$

/**
 * @file
 * Allows the creation and modification of pre-published, current and archived
 * content while the current revision remains unchanged and publicly visible
 * until the changes have been reviewed by a moderator.
 */
require_once drupal_get_path('module', 'revisioning') .'/revisioning_theme.inc';
require_once drupal_get_path('module', 'revisioning') .'/revisioning_triggers_actions.inc';

define('NEW_REVISION_WHEN_NOT_PENDING', 0);
define('NEW_REVISION_EVERY_SAVE', 1);
define('OLDEST_AT_TOP', 0);
define('NEWEST_AT_TOP', 1);

/**
 * Implementation of hook_help().
 */
function revisioning_help($path, $arg) {
  switch ($path) {
    case 'node/%/revisions':
      return '<p>'. t('To edit, publish or delete one of the revisions below, click on its saved date.') .'</p>';
    case 'admin/build/trigger/revisioning':
      return '<p>'. t("Below you can assign actions to run when certain publication-related events happen. For example, you could send an e-mail to an author when their content is pubished.") .'</p>';
  }
}

/**
 * Implementation of hook_perm().
 *
 * Revisioning permissions. Note that permissions to view, revert and delete
 * revisions already exist in node.module.
 */
function revisioning_perm() {
  return array('edit revisions', 'publish revisions', 'unpublish current revision');
}

/**
 * Implementation of hook_menu().
 *
 * Define new menu items.
 * Existing menu items are modified through hook_menu_alter().
 * @todo add "In draft" tab
 */
function revisioning_menu() {
  $items = array();

  // Add a tab to the 'I created' tab (defined in module_grants.module)
  $items['accessible-content/i-created/pending'] = array(
    'title' => 'In draft/Pending publication',
    'page callback' => '_show_pending_nodes',
    'page arguments' => array('view', I_CREATED),
    'access arguments' => array('access content summary'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -1
  );
  // Add a tab to the 'I last modified' tab (defined in module_grants.module)
  $items['accessible-content/i-last-modified/pending'] = array(
    'title' => 'In draft/Pending publication',
    'page callback' => '_show_pending_nodes',
    'page arguments' => array('view', I_LAST_MODIFIED),
    'access arguments' => array('access content summary'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -1
  );
   // Add a tab to the 'I can edit' tab (defined in module_grants.module)
  $items['accessible-content/i-can-edit/pending'] = array(
    'title' => 'In draft/Pending publication',
    'page callback' => '_show_pending_nodes',
    'page arguments' => array('update'),
    'access arguments' => array('access content summary'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -1
  );
  // Add a tab to the 'I can view' tab (defined in module_grants.module)
  $items['accessible-content/i-can-view/pending'] = array(
    'title' => 'In draft/Pending publication',
    'page callback' => '_show_pending_nodes',
    'page arguments' => array('view'),
    'access arguments' => array('access content summary'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -1
  );

  // Callback (not a menu item) to allow users to edit specified revision
  $items['node/%node/revisions/%/edit'] = array(
  //'title' => t('Edit revision'),
    'load arguments' => array(3),
    'page callback' => '_revision_edit',
    'page arguments' => array(1),
    'access callback' => 'module_grants_node_revision_access',
    'access arguments' => array('edit revisions', 1),
    'file' => 'node.pages.inc',
    'file path' => drupal_get_path('module', 'node'),
    'type' => MENU_CALL_BACK,
  );
  // Callback to allow users to publish revisions
  $items['node/%node/revisions/%/publish'] = array(
  //'title' => t('Publish revision'),
    'load arguments' => array(3),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('revisioning_publish_confirm', 1),
    'access callback' => 'module_grants_node_revision_access',
    'access arguments' => array('publish revisions', 1),
    'type' => MENU_CALLBACK,
  );
  // Callback to allow users to unpublish a node
  $items['node/%node/unpublish'] = array(
  //'title' => t('Unpublish'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('revisioning_unpublish_confirm', 1),
    'access callback' => 'module_grants_node_revision_access',
    'access arguments' => array('unpublish current revision', 1),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implementation of hook_menu_alter().
 *
 * Modify menu items defined in other modules (in particular the Node and
 * Module Grants modules).
 */
function revisioning_menu_alter(&$items) {

  // Change secondary filter tab default from Published' to 'In draft/Pending publication'
  $items['accessible-content']['page callback'] = '_show_pending_nodes';
  $items['accessible-content']['page arguments'] = array('view', I_LAST_MODIFIED);

  $items['accessible-content/i-created']['page callback'] = '_show_pending_nodes';
  $items['accessible-content/i-created']['page arguments'] = array('view', I_CREATED);
  $items['accessible-content/i-created/published']['type'] = MENU_LOCAL_TASK;
  $items['accessible-content/i-created/pending']['type']  = MENU_DEFAULT_LOCAL_TASK;

  $items['accessible-content/i-last-modified']['page callback'] = '_show_pending_nodes';
  $items['accessible-content/i-last-modified']['page arguments'] = array('view', I_LAST_MODIFIED);
  $items['accessible-content/i-last-modified/published']['type'] = MENU_LOCAL_TASK;
  $items['accessible-content/i-last-modified/pending']['type']  = MENU_DEFAULT_LOCAL_TASK;

  $items['accessible-content/i-can-edit']['page callback'] = '_show_pending_nodes';
  $items['accessible-content/i-can-edit']['page arguments'] = array('update');
  $items['accessible-content/i-can-edit/published']['type'] = MENU_LOCAL_TASK;
  $items['accessible-content/i-can-edit/pending']['type']  = MENU_DEFAULT_LOCAL_TASK;

  $items['accessible-content/i-can-view']['page callback'] = '_show_pending_nodes';
  $items['accessible-content/i-can-view']['page arguments'] = array('view');
  $items['accessible-content/i-can-view/published']['type'] = MENU_LOCAL_TASK;
  $items['accessible-content/i-can-view/pending']['type']  = MENU_DEFAULT_LOCAL_TASK;

  // Rename "View" tab
  $items['node/%node/view']['title'] = 'View current';

  // Remove "Edit" as a tab and redirect existing edit links to
  // _show_node_revisions() to ensure user picks desired revision first.
  $items['node/%node/edit']['page callback'] = '_show_node_revisions';
  $items['node/%node/edit']['type'] = MENU_CALLBACK;

  // "Revisions" tab remains but points to new page callback, which ensures users
  // pick the desired revision to view, edit, publish, revert, unpublish, delete.
  $items['node/%node/revisions']['page callback'] = '_show_node_revisions';

  // If Diff module is enabled, make sure it uses correct access callback
  if (module_exists('diff')) {
    $items['node/%node/revisions/view/%/%']['access callback'] = 'module_grants_node_revision_access';
    $items['node/%node/revisions/view/%/%']['access arguments'] = array('view revisions', 1);
  }

  // Apart from administrators, allow those that pass the 'trigger_access_check'
  // to configure the revisioning triggers. This means that users must have at
  // least 'administer actions' and 'access administration pages' (the latter is
  // to allow them to navigate to the trigger page via the menu).
  if (module_exists('trigger')) {
    $items['admin/build/trigger/revisioning']['access callback'] = 'trigger_access_check';
  }
}

/**
 * Return as a themed table a list of nodes that have pending revisions.
 * access rights of the logged-in user.
 *
 * @param $op
 *   Operation, one of 'view', 'update' or 'delete'.
 * @param $user_filter
 *   One of NO_FILTER, I_CREATED or I_LAST_MODIFIED.
 * @return
 *   themed HTML
 */
function _show_pending_nodes($op = 'view', $user_filter = -1) {
  global $user;
  $moderated_only = user_access('administer nodes') ? -1 : TRUE;
  $nodes = get_nodes($op, -1, 
    $user_filter == I_CREATED ? $user->uid : -1, 
    $user_filter == I_LAST_MODIFIED ? $user->uid : -1,
    $moderated_only, TRUE);
  return theme('nodes_summary', $nodes);
}

/**
 * Display all revisions of the supplied node in a themed table with
 * links for the permitted operations above it.
 */
function _show_node_revisions($node) {
  return _theme_revisions_summary($node);
}

/**
 * Implementation of hook_form_alter().
 *
 * Note: for cases where the FORM_ID is known a priori use
 * revisioning_form_FORM_ID_alter().
 */
function revisioning_form_alter(&$form, &$form_state, $form_id) {

  // Alter the Create/Edit form
  if (isset($form['#id']) && $form['#id'] == 'node-form') {
    $content_type = $form['type']['#value'];
    // Note that $form_id == $content_type_$form['#id']

    $form['options']['#collapsed'] = FALSE;

    // Only add this tick-box if user has the 'administer nodes' permission
    if (user_access('administer nodes')) {
      $form['revision_information']['revision_moderation'] = array(
        '#title' => t('New revision in draft, pending moderation'),
        '#type' => 'checkbox',
        '#default_value' => is_moderated($content_type)
      );
    }
    else {
      // Don't show tickbox, just set default on form
      $form['revision_moderation'] = array(
        '#type' => 'value',
        '#value' => is_moderated($content_type)
      );
    }

    $nid = $form['#node']->nid;
    if (!(empty($nid))) {
      // After saving an edit, redirect to revisions summary
      $form['#redirect'] = "/node/$nid/revisions";

      // Delete button needs special treatment
      if (isset($form['buttons']['delete'])) {
        $form['buttons']['delete']['#submit'] = array('_revision_delete_submit');
        if (_get_number_of_revisions($nid) > 1) {
          if (!user_access("delete revisions") || $form['#node']->vid == _get_current_revision_id($nid)) {
            // Disallow deletion of current revision as BAD things will happen if you do!
            unset($form['buttons']['delete']);
          }
          else {
            $form['buttons']['delete']['#value'] = 'Delete this revision';
          }
        }
      }
    }
  }
}

/**
 * Implementation of hook_node_type_form_alter().
 *
 * On content type edit form, add the "New revisions in moderation" tick-box
 * and a couple of radio-boxes to select the new revision and auto-publish
 * policies.
 */
function revisioning_form_node_type_form_alter(&$form, &$form_state) {
  $form['workflow']['#collapsed'] = FALSE;
  $form['workflow']['node_options']['#options']['revision_moderation'] = t('New revision in draft, pending moderation (requires "Create new revision")');

  $content_type = $form['#node_type']->type;
  $form['workflow']['revisioning'] = array(
    '#type' => 'fieldset',
    '#title' => t('New revision in draft'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE
  );
  $form['workflow']['revisioning']['new_revisions'] = array(
    '#title' => t('Create new revision'),
    '#type' => 'radios',
    '#options' => array(
      NEW_REVISION_WHEN_NOT_PENDING => t('Only when saving %type content that is not already in draft/pending moderation', array('%type' => $content_type)),
      NEW_REVISION_EVERY_SAVE       => t('Every time %type content is updated, even when saving content in draft/pending moderation', array('%type' => $content_type))),
    '#default_value' => (int)variable_get('new_revisions_'. $content_type, NEW_REVISION_WHEN_NOT_PENDING),
    '#description' => t('Use less disk space and avoid cluttering your revisions list. With the first option ticked, modifications are saved to the same copy (i.e. no additional revisions are created) until the content is published.')
    );
  $form['workflow']['revisioning']['revisioning_auto_publish'] = array(
    '#title' => t('Auto-publish drafts of type %type (for moderators)', array('%type' => $content_type)),
    '#type' => 'checkbox',
    '#default_value' => (int)variable_get('revisioning_auto_publish_'. $content_type, FALSE),
    '#description' => t('If this box is ticked and the logged-in user has the "publish revisions" permission, then any draft of type %type is published immeditaley upon saving, without further review.', array('%type' => $content_type))
  );
}

/**
 * Implementation of hook_nodeapi().
 */
function revisioning_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  $args = arg();
//drupal_set_message("'$op': " . implode('/', $args), 'error');

  $edit_user_profile = ($args[0] == 'user') && ($args[2] == 'edit') && !empty($args[3]);
  if (!($args[0] == 'node' || $edit_user_profile)) {
    // Only interested in URIs starting with /node or /user/<uid>/edit/<content_type>
    return;
  }
  
  if ($args[1] == 'add') {
    // /node/add/<content_type>; there is no 'add' for user profiles, only 'edit'
    _handle_new($node, $op); // 'presave', 'insert'
    return;
  }
  // Must have nid (when editing node) or uid (when editing user profile)
  if (!is_numeric($args[1])) {
    return;
  }
  if (end($args) == 'edit' || $edit_user_profile) {
    // node/<nid>/edit, node/<nid>/revisions/<vid>/edit, user/<uid>/edit
    _handle_edit($node, $op); // 'prepare', 'presave', 'update'
    return;
  }
  if ($op == 'alter') { // called just after $node object is fully built for display
    if (module_grants_node_revision_access('view revisions', $node)) {
      if (!$teaser && $node->nid == $args[1]) { // don't show msg on page with many nodes
        drupal_set_message(_get_node_info_msg($node));
      }
      global $theme_engine;
      if (!isset($theme_engine)) {
        _theme_content_menu($node);
      }
    }
  }
}

/**
 * Handle URLs of the form 'node/add/<content_type>'.
 * @param $node
 * @param $op, only listening to 'presave' and 'insert'
 * @return nothing
 */
function _handle_new(&$node, $op) {
  switch ($op) {
    case 'presave':
      if ($node->revision_moderation && !$node->status && variable_get('revisioning_auto_publish_'. $node->type, FALSE) && (user_access('publish revisions'))) {
        drupal_set_message(t('Auto-publishing initial draft as the first revision.'));
        $node->status = TRUE;
      }
      break;

    case 'insert':
      if ($node->status) {
        drupal_set_message(t('Initial revision created and published.'));
      }
      else {
        drupal_set_message(t('Initial draft created, pending publication.'));
      }
      break;
  }
}

/** Handle URLs of the form 'node/<nid>/edit'
 *
 * @param $node
 * @param $op, only listening to 'prepare', 'presave' and 'update'
 * @return nothing
 */
function _handle_edit(&$node, $op) {
  if ($op == 'prepare') {
    $count = _get_number_of_revisions_newer_than($node->vid, $node->nid);
    if ($count == 1) {
      drupal_set_message(t('Please note there is one revision more recent than the one you are about to edit.'), 'warning');
    }
    elseif ($count > 1) {
      drupal_set_message(t('Please note there are !count revisions more recent than the one you are about to edit.', array('!count' => $count)), 'warning');
    }
  }
  // Check if "Revisions in moderation" box ticked under Content types>>Workflow settings
  if ($node->revision_moderation) {
    switch ($op) {
      case 'presave': // called from start of node_save()
        $node->original_revision = $node->revision;
        if ($node->revision && variable_get('new_revisions_'. $node->type, NEW_REVISION_WHEN_NOT_PENDING) == NEW_REVISION_WHEN_NOT_PENDING) {
          if (_is_pending($node)) {
            drupal_set_message(t('Updating existing copy, not creating new revision as this one is still pending.'));
            $node->revision = FALSE;
          }
        }
        if (variable_get('revisioning_auto_publish_'. $node->type, FALSE) && user_access('publish revisions')) {
          // By-pass moderation and make sure node is published
          drupal_set_message(t('Auto-publishing this revision.'));
          $node->status = TRUE;
        }
        else {
          // Save the vid for subsequent restore during 'update' op
          $node->original_vid = _get_current_revision_id($node->nid);
        }
        break;

      case 'update': // called from end of node_save(), after _node_save_revision()
        $node->revision = $node->original_revision;
        if (isset($node->original_vid) && $node->original_vid != $node->vid) {
          // Resetting node vid back to its originial value, thus creating pending revision
          db_query("UPDATE {node} SET vid=%d WHERE nid=%d", $node->original_vid, $node->nid);
        }
        break;
    }
  }
  elseif ($op == 'update') {
    drupal_set_message(t('Your changes are now current as moderation is switched off for this content type.'), 'warning');
  }
}

/**
 * Menu callback; edit revision.
 */
function _revision_edit($node) {
  // Use the admin theme if the user specified this for node edit pages
  if (variable_get('node_admin_theme', FALSE)) {
    global $theme, $custom_theme;
    $custom_theme = variable_get('admin_theme', $theme);
  }
  drupal_set_title(check_plain($node->title));
  $form = drupal_get_form($node->type .'_node_form', $node);
  return $form;
}

/**
 * Return a confirmation page for publishing a revision.
 */
function revisioning_publish_confirm($form_state, $node) {
  $form['node_id']  = array('#type' => 'value', '#value' => $node->nid);
  $form['title']    = array('#type' => 'value', '#value' => $node->title);
  $form['revision'] = array('#type' => 'value', '#value' => $node->vid);
  $form['type']     = array('#type' => 'value', '#value' => $node->type);
  return confirm_form($form,
    t('Are you sure you want to publish this revision of %title?', array('%title' => $node->title)),
    'node/'. $node->nid .'/revisions',
    t('Publishing this revision will make it visible to the public.'),
    t('Publish'), t('Cancel'));
}

/**
 * Submission handler for the publish_confirm form.
 */
function revisioning_publish_confirm_submit($form, &$form_state) {
  $nid   = $form_state['values']['node_id'];
  $title = $form_state['values']['title'];
  $vid   = $form_state['values']['revision'];
  $type  = $form_state['values']['type'];
  _revisioning_publish_revision($nid, $vid, $title, $type);
  // Redirect to the same page as unpublish and revert
  $form_state['redirect'] = "node/$nid/revisions";
}

/**
 * Return a confirmation page for unpublishing the node.
 */
function revisioning_unpublish_confirm($form_state, $node) {
  $form['node_id'] = array('#type' => 'value', '#value' => $node->nid);
  $form['title']   = array('#type' => 'value', '#value' => $node->title);
  $form['type']    = array('#type' => 'value', '#value' => $node->type);
  return confirm_form($form,
    t('Are you sure you want to unpublish %title?', array('%title' => $node->title)),
    "node/$node->nid/revisions",
    t('Unpublishing will remove this content from public view.'),
    t('Unpublish'), t('Cancel'));
}

/**
 * Submission handler for the unpublish_confirm form.
 */
function revisioning_unpublish_confirm_submit($form, &$form_state) {
  $nid   = $form_state['values']['node_id'];
  $title = check_plain($form_state['values']['title']);
  $type  = check_plain($form_state['values']['type']);
  db_query("UPDATE {node} SET status=0 WHERE nid=%d", $nid);
  cache_clear_all();
  drupal_set_message(t('%title has been unpublished.', array('%title' => $title)));
  watchdog('content', 'Unpublished @type %title', array('@type' => $type, '%title' => $title), WATCHDOG_NOTICE, l(t('view'), "node/$nid"));
  // Redirect to the same page as publish and revert
  $form_state['redirect'] = "node/$nid/revisions";
  // Invoke the revisioning trigger passing 'unpublish' as the operation
  module_invoke_all('revisioning', 'unpublish');
}

/**
 * Implementation of hook_form_FORM_ID_alter(), see node.pages.inc/node_revision_revert_confirm()
 */
function revisioning_form_node_revision_revert_confirm_alter(&$form, &$form_state) {
  $node = $form['#node_revision'];
  if (_get_number_of_pending_revisions($node->nid) > 0) {
    drupal_set_message(t('There is a pending revision. Are you sure you want to revert to an archived revision?'), 'warning');
  }
  $form['#submit'][] = 'revisioning_revert_confirm_submit';
}

/**
 * Submission handler for the revert_confirm form.
 *
 * Forward on to the existing revert function in node.pages.inc, then triggers
 * a 'revert' event that may be actioned upon.
 *
 * Note:
 * It would be nice if publish and revert were symmetrical operations and that
 * node_revision_revert_cofirm_submit didn't save a copy of the revision (under
 * a new vid), as this has the side-effect of making all "pending" revisions
 * "old". This is because the definition of "pending" is:
 * "node_vid > current_vid".
 * It would be better if "pending" relied on a separate flag rather than a field
 * such as vid (or a timestamp) that changes everytime a piece of code executes
 * a node_save.
 */
function revisioning_revert_confirm_submit($form, &$form_state) {
  $node = $form['#node_revision'];
  // Make sure the node gets published, i.e. has its status flag set
  db_query("UPDATE {node} SET status=1 WHERE nid=%d", $node->nid);
  cache_clear_all();
  // Invoke the revisioning trigger passing 'revert' as the operation
  module_invoke_all('revisioning', 'revert');
}

/**
 * Handle the 'Delete' button on the edit form
 *
 * Redirect to revision deletion confirm (as opposed to node deletion confirm).
 */
function _revision_delete_submit(&$form, &$form_state) {
  $node = $form['#node'];
  $form['#redirect'] =  (_get_number_of_revisions($node->nid) == 1)
    ? "node/$node->nid/delete" // delete entire node
    : "node/$node->nid/revisions/$node->vid/delete";
}

/**
 * Implementation of hook_form_FORM_ID_alter(), see node.pages.inc/node_delete_confirm()
 * This is called when the 'Delete all revisions' link is pressed
 */
function revisioning_form_node_delete_confirm_alter(&$form, &$form_state) {
  $form['#redirect'] = 'accessible-content';
}

/**
 * Make the supplied revision of the node current and publish it.
 *
 * @param $nid
 *   The id of the node
 * @param $vid
 *   The id of the revision that is to be made current
 * @param $title
 *   The title of the revision that is to be made current
 * @param $type
 *   The node's content type (eg "story"), supplied only to make watchdog msg
 *   consistent with the node.module watchdog msgs.
 */
function _revisioning_publish_revision($nid, $vid, $title, $type) {
  // Update node table, making sure the "published" (ie. status) flag is set
  db_query("UPDATE {node} SET vid=%d, title='%s', status=1 WHERE nid=%d", $vid, $title, $nid);
  cache_clear_all();
  drupal_set_message(t('Revision has been published.'));
  watchdog('content', 'Published rev #%revision of @type %title', array('@type' => check_plain($type), '%title' => check_plain($title), '%revision' => $vid), WATCHDOG_NOTICE, l(t('view'), "node/$nid/revisions/$vid/view"));
  // Invoke the revisioning trigger passing 'publish' as the operation
  module_invoke_all('revisioning', 'publish');
}

/**
 * Find the most recent pending revision and make it current, unless it already is.
 *
 * @param $node
 *   The node object whose latest pending revision is to be published
 */
function revisioning_publish_latest_revision($node) {
  // Get latest pending revision or take the current provided it's UNpublished
  $latest_pending = array_shift(_get_pending_revisions($node->nid));
  if (!$latest_pending) {
    if (!$node->status && $node->vid == _get_current_revision_id($node->nid)) {
      $latest_pending = $node;
    }
  }
  if ($latest_pending) {
    _revisioning_publish_revision($node->nid, $latest_pending->vid, $latest_pending->title, $latest_pending->type);
  }
  else {
    drupal_set_message(t('"!title" has no pending revision to be published.', array('!title' => $node->title)), 'warning');
  }
}

/**
 * Get the number of revisions belonging to a node.
 * @param
 *  $nid, id of the node
 * @return
 *  A count representing the number of revisions associated with the node
 */
function _get_number_of_revisions($nid) {
  return db_result(db_query("SELECT COUNT(vid) FROM {node_revisions} WHERE nid=%d", $nid));
}

/**
 * Return a count of the number of revisions newer than the supplied vid.
 *
 * @param $vid
 *  The reference vid.
 * @param $nid
 *  The id of the node.
 * @return
 *  integer
 */
function _get_number_of_revisions_newer_than($vid, $nid) {
  return db_result(db_query("SELECT COUNT(*) FROM {node} n INNER JOIN {node_revisions} r ON n.nid=r.nid WHERE (r.vid>%d AND n.nid=%d)", $vid, $nid));
}

/**
 * Return a count of the number of revisions newer than the current revision.
 *
 * @param $nid
 *  The id of the node.
 * @return
 *  integer
 */
function _get_number_of_pending_revisions($nid) {
  return db_result(db_query("SELECT COUNT(*) FROM {node} n INNER JOIN {node_revisions} r ON n.nid=r.nid WHERE (r.vid>n.vid AND n.nid=%d)", $nid));
}

/**
 * Retrieve a list of revisions with a vid greater than the current.
 *
 * @param $nid
 *  The node id to retrieve.
 * @return
 *  An array of revisions (latest first), each containing vid, title and
 *  content type.
 */
function _get_pending_revisions($nid) {
  $sql = "SELECT r.vid, r.title, n.type FROM {node} n INNER JOIN {node_revisions} r ON n.nid=r.nid WHERE (r.vid>n.vid AND n.nid=%d) ORDER BY r.vid DESC";
  $result = db_query($sql, $nid);
  $revisions = array();
  while ($revision = db_fetch_object($result)) {
    $revisions[$revision->vid] = $revision;
  }
  return $revisions;
}

/**
 * Retrieve a list of all revisions (archive, current, pending) belonging to
 * the supplied node.
 *
 * @param $nid
 *  The node id to retrieve.
 * @param $include_taxonomy_terms
 *  Whether to also retrieve the taxonomy terms for each revision
 * @return
 *  An array of revision objects, each with published flag, log message, vid,
 *  title, timestamp and name of user that created the revision
 */
function _get_all_revisions_for_node($nid, $include_taxonomy_terms = FALSE) {
  $sql_select = 'SELECT n.status, r.vid, r.title, r.log, r.uid, r.timestamp, u.name';
  $sql_from   = ' FROM {node_revisions} r LEFT JOIN {node} n ON n.vid=r.vid INNER JOIN {users} u ON u.uid=r.uid';
  $sql_where  = ' WHERE r.nid=%d ORDER BY r.vid DESC';
  if ($include_taxonomy_terms) {
    $sql_select .= ', td.name AS term';
    $sql_from .= ' LEFT JOIN {term_node} tn ON r.vid=tn.vid LEFT JOIN {term_data} td ON tn.tid=td.tid';
    $sql_where .= ', term ASC';
  }
  $sql = $sql_select . $sql_from . $sql_where;
  $result = db_query($sql, $nid);
  $revisions = array();
  while ($revision = db_fetch_object($result)) {
    if (empty($revisions[$revision->vid])) {
      $revisions[$revision->vid] = $revision;
    }
    elseif ($include_taxonomy_terms) {
      // If a revision has more than one taxonomy term, these will be returned
      // by the query as seperate objects differing only in their term fields.
      $existing_revision = $revisions[$revision->vid];
      $existing_revision->term .= '/'. $revision->term;
    }
  }
  return $revisions;
}

/**
 * Return a string with details about the node that is about to be displayed.
 *
 * Called from revisioning_nodeapi().
 *
 * @param $node
 *  The node that is about to be viewed
 * @return
 *  A translatable message containing details about the node
 */
function _get_node_info_msg($node) {
  // Get username for the revision, not the creator of the node
  $revision_author = user_load($node->revision_uid);
  $placeholder_data =
    array('@content_type' => $node->type,
          '%title' => check_plain($node->title),
          '!author' => theme('username', $revision_author),
          '@date' => format_date($node->revision_timestamp, 'small'));
  $current_vid = _get_current_revision_id($node->nid);
  $is_pending = ($node->vid > $current_vid) || (!$node->status && _get_number_of_revisions($node->nid) == 1);
  if ($is_pending) {
    $msg = t('Displaying <em>pending</em> revision of @content_type %title, last modified by !author on @date', $placeholder_data);
  }
  else {
    $msg = ($current_vid == $node->vid) && $node->status
      ? t('Displaying <em>current, published</em> revision of @content_type %title, last modified by !author on @date', $placeholder_data)
      : t('Displaying <em>archived</em> revision of @content_type %title, last modified by !author on @date', $placeholder_data);
  }
  return $msg;
}

/**
 * Return an array of hyperlinks representing the operations the logged-in user
 * is allowed to perform on the supplied node.
 *
 * @param 
 *  $node
 * @return 
 *  array of hyperlinks
 */
function generate_node_links_according_to_permissions($node) {
  $links = array();
  if ($node->status && module_grants_node_revision_access('unpublish current revision', $node)) {
    $links[] = l(t('Unpublish current revision'), "node/$node->nid/unpublish");
  }
  if (module_grants_node_access('delete', $node)) {
    $links[] = l(t('Delete all revisions'), "node/$node->nid/delete");;
  }
  return $links;
}

/**
 * Return an array of hyperlinks representing the operations the logged-in user
 * is allowed to perform on the supplied revision.
 *
 * @param 
 *  $node
 * @return
 *  array of hyperlinks
 */
function generate_revision_links_according_to_permissions($node) {
  $access_view      = module_grants_node_revision_access('view revisions', $node);
  $access_edit      = module_grants_node_revision_access('edit revisions', $node);
  $access_delete    = module_grants_node_revision_access('delete revisions', $node);
  $access_publish   = module_grants_node_revision_access('publish revisions', $node);
  $access_revert    = module_grants_node_revision_access('revert revisions', $node);
  $access_unpublish = module_grants_node_revision_access('unpublish current revision', $node);

  $current_revision_id = _get_current_revision_id($node->nid);
  $is_current = ($node->vid == $current_revision_id);
  $is_pending = ($node->vid > $current_revision_id);

  $links = array(); // Links to compare/revert/publish/delete revisions
  if ($access_view) {
    // Add a link to the diff if we have Diff module installed.
    if (!$is_current && module_exists('diff')) {
      $comparison_url = "node/$node->nid/revisions/view/";
      // Make sure that latest of the two revisions is on the right
      if ($is_pending) {
        $comparison_url .= "$current_revision_id/$node->vid";
      }
      else {
        $comparison_url .= "$node->vid/$current_revision_id";
      }
      $links[] = l(t('Compare to current'), $comparison_url);
    }
  }
  $base_url = "node/$node->nid/revisions/$node->vid";
  if ($access_edit) {
    $links[] = l(t('Edit this revision'), "$base_url/edit");
  }
  // If this revision is pending or current but not published, return a
  // publish link, otherwise show a revert link.
  if ($access_publish && ($is_pending || ($is_current && !$node->status))) {
    $links[] = l(t('Publish this revision'), "$base_url/publish");
  }
  elseif ($access_revert && !$is_pending && !$is_current) {
    $links[] = l(t('Revert to this revision'), "$base_url/revert");
  }
  if ($access_unpublish && $is_current && $node->status) {
    $links[] = l(t('Unpublish this revision'), "node/$node->nid/unpublish");
  }
  if ($access_delete && !$is_current) {
    // Don't provide link to delete current -- node must point to a revision.
    $links[] = l(t('Delete this revision'), "$base_url/delete");
  }
  $args = arg();
  if ($access_view && $args[2] == 'revisions') {
    // Don't provide link to 'Show all revisions' when Revisions tab is available
    $links[] = l(t('Show all revisions'), "node/$node->nid/revisions");
  }
  return $links;
}

/**
 * Get the id of the current revision that the supplied node is pointing to.
 * Used in cases where the node object wasn't fully loaded or was loaded
 * with a different revision.
 *
 * @param $nid
 *  The id of the node whose current revision id is to be returned.
 * @return
 *  A single number being the current revision id (vid).
 */
function _get_current_revision_id($nid) {
  return db_result(db_query('SELECT vid FROM {node} WHERE nid=%d', $nid));
}

/**
 * Return whether the node has a pending revision, that is a revision newer
 * than the current OR when there's only one revision, whether that revision is
 * unpublished.
 *
 * @param 
 *  $node
 * @return 
 *  TRUE, if the node has a pending revision.
 */
function _is_pending($node) {
  return ($node->vid > _get_current_revision_id($node->nid)) ||
    (!$node->status && _get_number_of_revisions($node->nid) == 1) ;
}

/**
 * Implementation of hook_token_values().
 */
function revisioning_token_values($type, $object = NULL, $options = array()) {
  $values = array();
  switch ($type) {
    case 'node':
      $values['vid'] = $object->vid;
      break;

    case 'op':
      switch ($object) {
        case 'publish':
        case 'revert':
        case 'unpublish':
          $node = node_load(array('nid' => arg(1)));
          $values = node_token_values('node', $node, $options);
          $values['vid'] = $node->vid;
      }
      break;
  }
  return $values;
}

/**
 * Implementation of hook_token_list().
 */
function revisioning_token_list($type = 'all') {
  if ($type == 'node' || $type == 'all') {
    $tokens = array();
    $tokens['node']['vid'] = t('Node revision ID');
    return $tokens;
  }
}

/**
 * Implementation of hook_block().
 *
 * A block that may be placed on all or selected pages, alterting the user
 * (moderator) when new content has been submitted for review. Shows as a
 * series of up to 5 links the titles of pending revisions.
 * Clicking a link takes the moderator straight to the revision in question.
 */
function revisioning_block($op = 'list', $delta = 0, $edit = array()) {
  switch ($op) {
    case 'list':
      // Set up the defaults for the Site configuration>>Blocks page
      // Return a list of (1) block(s) and the default values
      $blocks[0]['info'] = t('Pending revisions');
      $blocks[0]['cache'] = BLOCK_NO_CACHE;
      $blocks[0]['weight'] = -10; // top of whatever region is chosen
      $blocks[0]['custom'] = FALSE; // block is implemented by this module;
      return $blocks;

    case 'configure':
      $form['revisioning_block_num_pending'] = array(
        '#type' => 'textfield',
        '#title' => t('Maximum number of pending revisions displayed'),
        '#default_value' => variable_get('revisioning_block_num_pending', 5),
        '#description' => t('Note: the title of this block mentions the total number of revisions pending, which may be greater than the number of revisions displayed.')
      );
      $form['revisioning_block_order'] = array(
        '#type' => 'radios',
        '#title' => t('Order in which pending revisions are displayed'),
        '#options' => array(
          OLDEST_AT_TOP => t('Oldest at top'),
          NEWEST_AT_TOP => t('Newest at top')),
        '#default_value' => variable_get('revisioning_block_order', OLDEST_AT_TOP),
        '#description' => t('Note: order is based on revision timestamps.')
      );
      return $form;

    case 'save':
      variable_set('revisioning_block_num_pending', (int)$edit['revisioning_block_num_pending']);
      variable_set('revisioning_block_order', (int)$edit['revisioning_block_order']);
      break;

    case 'view':
      if (user_access('view revisions') && (user_access('publish revisions') || user_access('administer nodes'))) {
        $order = variable_get('revisioning_block_order', OLDEST_AT_TOP) == OLDEST_AT_TOP ? 'ASC' : 'DESC';
        $nodes = get_nodes('update', NO_FILTER, NO_FILTER, NO_FILTER, TRUE, TRUE, 100, FALSE, 'timestamp '. $order);
        if (!empty($nodes)) {
          return _theme_revisions_pending_block($nodes);
        }
      }
  }
}

/**
 * Implementation of hook_views_api().
 */
function revisioning_views_api() {
  return array(
    'api' => views_api_version(),
    'path' => drupal_get_path('module', 'revisioning')
  );
}
